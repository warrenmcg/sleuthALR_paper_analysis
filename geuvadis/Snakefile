include: '../config.py'

from os.path import isfile

rule init:
    output:
        'metadata/geu_meta.RData',
        'metadata/accession.txt',
        'metadata/finn_samples.txt'
    shell:
        source_r('R', 'metadata.R')

# TODO: put this at the beginning of the pipeline (run it before everything)
ACCESSION_FILE = 'metadata/accession.txt'
ERA_SINGLE = []
if isfile(ACCESSION_FILE):
    ERA_SINGLE = get_sample_ids(ACCESSION_FILE)
else:
    # force running the init
    print('Warning: the accession file is missing or the init script has not yet been run. Running now.')
    rule:
        input: rules.init.output

SAMPLES_FILE = 'metadata/finn_samples.txt'
FINN_SAMPLES = []
if isfile(SAMPLES_FILE):
    with open('metadata/finn_samples.txt', 'r') as input:
        for line in input:
            FINN_SAMPLES.append(line.strip())
else:
    # force running the init
    print('Warning: the finn_samples.txt file is missing or init script has not yet been run. Running now.')
    rule:
        input: rules.init.output

rule all:
    input:
        # get all the metadata we need from geuvadis
        'metadata/geu_meta.RData',
        'results/finn_subsamples.rds',
        expand('finn_samples/{id}/{id}_{i}.fastq.gz', id = FINN_SAMPLES, i = [1, 2]),

        # used for null experiment
        expand('results/finn_samples/{id}/abundance.h5', id = FINN_SAMPLES),
        expand('results/finn_samples/{id}/hisat.bam', id = FINN_SAMPLES),
        expand('results/finn_samples/{id}/featureCounts.txt', id = FINN_SAMPLES),
        'results/null_resampling_fdr_report.html',

        # do a large experiment so that we can do permutations
        'results/simulation/isoform_benchmarks.rds',
        'results/simulation/gene_benchmarks.rds',
        'results/simulation/benchmark_report.html'

def finn_sample_input(wildcards):
    id = wildcards['id']
    return expand('finn_samples/{id}/{id}_{i}.fastq.gz', id = id, i = [1, 2])

rule fastq_dump:
    input:
        ERA_SINGLE
    output:
        'finn_samples/{id,[A-Z]+[0-9]+}',
        finn_sample_input
    threads: 1
    shell:
        'mkdir finn_samples/{wildcards.id} && '
        ' wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR188/{input[0]}/{input[0]}_1.fastq.gz && '
        ' wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR188/{input[0]}/{input[0]}_2.fastq.gz && '
        ' rename \'s/{input[0]}/{wildcards.id}/\' {input[0]}_*fasta.gz && '
        ' mv {output[1]} {output[2]} {output[0]}'

rule finn_samples:
    input:
        finn_sample_input
    output:
        'results/finn_samples/{id}/abundance.h5'
    threads: 5
    shell:
        '{UPDATED_PATH} '
        'kallisto quant'
        ' -i {KALLISTO_INDEX}'
        ' -b 30'
        ' -o {output[0]}'
        ' -t {threads}'
        ' {input[0]} {input[1]}'

rule prep_null_resampling:
    input:
        'metadata/geu_meta.RData',
        'results/finn_samples/{id}/abundance.h5'
    output:
        'results/finn_subsamples.rds'
    shell:
        source_r('R', 'resampling_fdr.R')

rule finn_hisat_alignment:
    input:
        finn_sample_input
    output:
        'results/finn_samples/{id}/hisat.bam'
    threads: 10
    benchmark:
        'benchmark/finn_samples/{id}/hisat/benchmark.json'
    shell:
        '{UPDATED_PATH}'
        ' hisat2'
        ' -x {HISAT_INDEX}'
        ' -1 {input[0]}'
        ' -2 {input[1]}'
        ' --dta-cufflinks'
        ' -p {threads}'
        ' | '
        '{UPDATED_PATH} samtools view -Sb -'
        ' > '
        '{output}.unsorted'
        ' && '
        '{UPDATED_PATH} samtools sort'
        ' -o {output}'
        ' {output}.unsorted'
        ' && '
        'rm {output}.unsorted'

rule finn_featureCounts:
    input:
        'results/finn_samples/{id}/hisat.bam'
    output:
        'results/finn_samples/{id}/featureCounts.txt'
    benchmark:
        'benchmark/finn_samples/{id}/featureCounts/benchmark.json'
    threads: 2
    shell:
        '{UPDATED_PATH} '
        'featureCounts '
        ' -a {TRANSCRIPTOME_GTF}'
        ' -o {output}'
        ' -T {threads}'
        ' -p'
        ' {input}'

rule null_resampling_isoform:
    input:
        expand('results/finn_samples/{id}/abundance.h5', id = FINN_SAMPLES),
        expand('results/finn_samples/{id}/featureCounts.txt', id = FINN_SAMPLES)
    output:
        'results/null_resampling/isoform.rds'
    threads: 20
    shell:
        source_r('R', 'null_resampling_fdr_isoform.R') + ' {threads}'

rule null_resampling_gene:
    input:
        expand('results/finn_samples/{id}/abundance.h5', id = FINN_SAMPLES),
        expand('results/finn_samples/{id}/featureCounts.txt', id = FINN_SAMPLES)
    output:
        'results/null_resampling/gene.rds'
    threads: 20
    shell:
        source_r('R', 'null_resampling_fdr_gene.R') + ' {threads}'

rule null_resampling_fdr_report:
    input:
        'results/null_resampling/isoform.rds',
        'results/null_resampling/gene.rds',
    output:
        'results/null_resampling_fdr_report.html'
    shell:
        source_rmd('R', 'null_resampling_fdr_report.Rmd', '../results/null_resampling_fdr_report.html')

###
# simulation generation
###

# this simulation deals with modeling independent differential usage amongst the isoforms
# basically, every isoform is looked at independently and decides whether or not it will be
# differentially expressed independently.
rule gen_sim_script_isoform:
    input:
        'results/prep_fin.RData'
    output:
        'sims/isoform_{n_a,\d+}_{n_b}_{n_sim}_{seed,\d+}_{sf,\d+}',
        'sims/isoform_{n_a,\d+}_{n_b}_{n_sim}_{seed}_{sf}/sims.rds'
    shell:
        source_r('R', 'gen_sim.R') + ' '
        'isoform_{wildcards.n_a}_{wildcards.n_b}_{wildcards.n_sim}_{wildcards.seed}_{wildcards.sf} '
        ' {wildcards.n_sim}'
        ' {wildcards.n_a}'
        ' {wildcards.n_b}'
        ' {wildcards.seed}'
        ' {wildcards.sf}'

rule make_simulation:
    input:
        'sims/{experiment}/sims.rds'
    output:
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_1.fq.gz',
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_2.fq.gz'
    params:
        sims = 'sims/{experiment}/exp_{num}/{id}'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/make_simulation/benchmark.json'
    shell:
        '{UPDATED_PATH}'
        ' {params.sims}/sim_{wildcards.id}.sh'
        ' {RSEM_ANNOTATION}'
        ' {RSEM_MODEL}'
        ' {params.sims}'

rule hisat_alignment:
    input:
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_1.fq.gz',
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_2.fq.gz'
    output:
        'sims/{experiment}/exp_{num}/{id}/hisat.bam'
    threads: 10
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/hisat/benchmark.json'
    shell:
        '{UPDATED_PATH}'
        ' hisat2'
        ' -x {HISAT_INDEX}'
        ' -1 {input[0]}'
        ' -2 {input[1]}'
        ' --dta-cufflinks'
        ' -p {threads}'
        ' | '
        '{UPDATED_PATH} samtools view -Sb -'
        ' > '
        '{output}.unsorted'
        ' && '
        '{UPDATED_PATH} samtools sort'
        ' -o {output}'
        ' {output}.unsorted'
        ' && '
        'rm {output}.unsorted'

rule featureCounts:
    input:
        'sims/{experiment}/exp_{num,\d+}/{id,\d+}/hisat.bam'
    output:
        'sims/{experiment}/exp_{num,\d+}/{id,\d+}/featureCounts.txt'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/featureCounts/benchmark.json'
    threads: 5
    shell:
        '{UPDATED_PATH} '
        'featureCounts '
        ' -a {TRANSCRIPTOME_GTF}'
        ' -o {output}'
        ' -T {threads}'
        ' -p'
        ' {input}'

def get_feature_counts(wildcards):
    experiment = wildcards['experiment']
    info = get_simulation_info(experiment)
    num = wildcards['num']
    ids = range(1, info['a'] + info['b'] + 1)

    return expand(
        'sims/{experiment}/exp_{num}/{id}/featureCounts.txt',
        experiment = experiment,
        num = num,
        id = ids)

rule aggregate_counts:
    input:
        get_feature_counts
    output:
        'sims/{experiment}/exp_{num,\d+}/results/featureCounts/counts.tsv'
    params:
        base = 'sims/{experiment}/exp_{num}'
    threads: 1
    shell:
        source_r('R', 'merge_counts.R') +  ' ../{params.base} ../{output}'

rule kallisto:
    input:
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_1.fq.gz',
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_2.fq.gz'
    output:
        'sims/{experiment}/exp_{num}/{id}/kallisto',
        'sims/{experiment}/exp_{num}/{id}/kallisto/abundance.h5',
        'sims/{experiment}/exp_{num}/{id}/kallisto/abundance.tsv'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/kallisto/benchmark.json'
    threads: 5
    shell:
        '{UPDATED_PATH} '
        'kallisto quant'
        ' -i {KALLISTO_INDEX}'
        ' -b 100'
        ' -o {output[0]}'
        ' -t {threads}'
        ' {input[0]} {input[1]}'
        # ' <(zcat {input[0]}) <(zcat {input[1]})'

def get_sleuth(wildcards):
    experiment = wildcards['experiment']
    info = get_simulation_info(experiment)
    num = wildcards['num']
    ids = range(1, info['a'] + info['b'] + 1)
    return expand('sims/{experiment}/exp_{num}/{id}/kallisto/abundance.h5',
        experiment = experiment,
        num = num,
        id = ids)
rule sleuth:
    input:
        get_sleuth
    output:
        'sims/{experiment}/exp_{num,\d+}/results/sleuth'
    shell:
        'touch {output}'

N_SIM = 20
def get_gene_dependencies(wildcards):
    exp = wildcards['experiment']
    ret = []
    ret += expand('sims/{exp}/exp_{num}/results/sleuth', exp = exp,
        num = range(1, N_SIM + 1))
    ret += expand('sims/{exp}/exp_{num}/results/featureCounts/counts.tsv', exp = exp,
        num = range(1, N_SIM + 1))
    return ret
rule benchmark_gene:
    input:
        get_gene_dependencies
    output:
        'results/{experiment}/gene_benchmarks.rds'
    threads:
        N_SIM
    shell:
        source_r('R', 'bench_gene.R') + ' {threads} {wildcards.experiment}'

rule benchmark_gene_filter:
    input:
        get_gene_dependencies
    output:
        'results/{experiment}/gene_benchmarks_filter.rds'
    threads:
        N_SIM
    shell:
        source_r('R', 'best_filter_gene.R') + ' {threads} {wildcards.experiment}'

N_SIM = 20
def get_isoform_dependencies(wildcards):
    exp = wildcards['experiment']
    ret = []
    ret += expand('sims/{exp}/exp_{num}/results/sleuth', exp = exp,
        num = range(1, N_SIM + 1))
    return ret
rule benchmark_isoform:
    input:
        get_isoform_dependencies
    output:
        'results/{experiment}/isoform_benchmarks.rds'
    threads:
        N_SIM
    shell:
        source_r('R', 'bench_isoform.R') + ' {threads} {wildcards.experiment}'

rule benchmark_isoform_filter:
    input:
        get_isoform_dependencies
    output:
        'results/{experiment}/isoform_benchmarks_filter.rds'
    threads:
        N_SIM
    shell:
        source_r('R', 'best_filter_isoform.R') + ' {threads} {wildcards.experiment}'

rule benchmark_report:
    input:
        'results/{experiment}/isoform_benchmarks.rds',
        'results/{experiment}/gene_benchmarks.rds',
    output:
        'results/{experiment}/benchmark_report.html',
    threads:
        1
    shell:
        source_rmd('R', 'benchmark_report.Rmd',
            '../results/{wildcards.experiment}/benchmark_report.html') +
        ' {threads} {wildcards.experiment}'
